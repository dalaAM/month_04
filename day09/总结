淘汰策略(redis中key的删除规则)
​	1.主动出击
​		把所有带过期时间的key另外的存储到一个字典当中,定期扫描,判断key是否过期,
        默认每100毫秒进行一次过期扫描
        1>在过期字典中随机的选择20个key
        2>检查过期的key,删除已经到期的
        3>如果过期的key比例超过1/4,重复执行1~3步骤
        默认的超过时间是25秒,避免扫描卡死.
   2.惰性删除 get key,如果该key已经过期,则删除
   3.redis检查内存的使用超过maxmemory,开始暴力淘汰策略
    3.1 noeviction-拒绝写服务,可以接收读的请求.[默认值]
    3.2 volatile-lru-尝试删除带过期时间但是很少使用的key
    3.3 allkeys-lru -尝试删除所有很少使用的key[最少使用原则]
        如何判断key值使用次数最少?
            假设一个队列中是三个key,在每次使用key的时候就将使用的key放到队列的最上边,当长时间不使用某一个key时,
            就将这个key放到队列最低处


位图操作:
    可以进行实时的统计用户的登录信息? (如:那些用户那几天登录过?),且及其节省内存空间
    如不引入位图操作:(统计用户信息)
        1_login:[20200518,20200615]
        2_login:[20200614,20200323]
        如果一个用户一年都在登录,则key值有365个
        在有许多用户的前提下一年都在登录,则会耗费大量的内存空间
    引入位图操作:(设1年中的第一天为0位,最后一天为364位,'1'和'0'表示登录或者没有登录)
        1_login:01000100011011
        2_login:01000100011011
        这样操作则会俭省大量的内存空间











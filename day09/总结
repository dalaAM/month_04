淘汰策略(redis中key的删除规则)
​	1.主动出击
​		把所有带过期时间的key另外的存储到一个字典当中,定期扫描,判断key是否过期,
        默认每100毫秒进行一次过期扫描
        1>在过期字典中随机的选择20个key
        2>检查过期的key,删除已经到期的
        3>如果过期的key比例超过1/4,重复执行1~3步骤
        默认的超过时间是25秒,避免扫描卡死.
   2.惰性删除 get key,如果该key已经过期,则删除
   3.redis检查内存的使用超过maxmemory,开始暴力淘汰策略
    3.1 noeviction-拒绝写服务,可以接收读的请求.[默认值]
    3.2 volatile-lru-尝试删除带过期时间但是很少使用的key
    3.3 allkeys-lru -尝试删除所有很少使用的key[最少使用原则]
        如何判断key值使用次数最少?
            假设一个队列中是三个key,在每次使用key的时候就将使用的key放到队列的最上边,当长时间不使用某一个key时,
            就将这个key放到队列最低处


位图操作:
    可以进行实时的统计用户的登录信息? (如:那些用户那几天登录过?),且及其节省内存空间
    如不引入位图操作:(统计用户信息)
        1_login:[20200518,20200615]
        2_login:[20200614,20200323]
        如果一个用户一年都在登录,则key值有365个
        在有许多用户的前提下一年都在登录,则会耗费大量的内存空间
    引入位图操作:(设1年中的第一天为0位,最后一天为364位,'1'和'0'表示登录或者没有登录)
        1_login:01000100011011
        2_login:01000100011011
        这样操作则会俭省大量的内存空间
        操作时统计字节的整数倍
    使用场景:
        用户登录信息统计,活跃度统计
        a:0110 0001
        b:0110 0010
        q:0111 0001
        r:0111 0010

Hash散列数据类型
    1、由field和关联的value组成的键值对
    2、field和value是字符串类型
    3、一个hash中最多包含2^32-1个键值对
    key:str
    key:[v1,v2,v3] 列表
    key:{f1:v1,f2:v2,f3:v3} 字典
    使用hash散列操作
        优点:节约内存空间,字段不能超过512个,value超过64个字节
            可按需获取字段的值,(file与file之间相互独立,不需要索引,f1和f2同属于一个key)
        缺点:
            使用过期键功能:键过期功能只能对键进行过期操作,而不能对散列的字段进行过期操作
    在redis中但凡字典操作命令都已'H'操作,列表操作命令都已'L'操作,集合操作命令都已'S'操作,有序集合操作命令都已'C'操作


model:
class user:
    username
    age
    1.获取用户信息:
    url:user/detail/1
    views中的相关使用函数
    if 缓存中有数据 redis
        return 缓存中的数据

    else:
        从数据库当中查询 -->mysql
        将数据存到缓存 -->redis (如何存?)
        return 数据

    2.更新用户信息:
    url:user/update/<int:user_id>
    更新前需要设置post提交(需要添加模板)
        user/update/1?age =30
    view中添加相关函数
        1查 2改 3保存
        删除redis中的缓存













